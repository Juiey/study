## 1. 預防死鎖

**目標**：在系統運作前採取措施，確保不會發生死鎖。

**方法**：破壞死鎖所產生的四個必要條件中的一個或多個，例如：

- **破壞互斥條件**：使資源可以共享，避免資源獨佔。
- **破壞請求和保持條件**：要求進程在持有資源時不能請求新的資源。
- **破壞不剝奪條件**：允許系統強制剝奪資源。
- **破壞循環等待條件**：確保資源請求以某一順序進行，避免形成循環等待。

## 2. 避免死鎖

**目標**：透過動態分配資源，防止系統進入不安全狀態，從而避免死鎖。

**方法**：例如銀行家演算法，在資源分配時，模擬資源分配後的狀態，只有當資源分配不會導致死鎖時，才實際分配資源。

**缺點**：

- 資源申請分析和計算複雜，系統開銷大。
- 很難在進程執行前精確掌握每個進程所需的最大資源數。

## 3. 偵測死鎖

**目標**：允許系統在運作過程中發生死鎖，但透過偵測機制及時偵測出死鎖。

**方法**：使用資源分配圖或其他演算法定期檢查系統的狀態，偵測是否有死鎖。
**缺點**：需要透過剝奪資源解除死鎖，可能對系統或使用者造成損失。

## 4. 解除死鎖

**目標**：在偵測到死鎖後，採取措施將程序從死鎖狀態中解脫出來。

**方法**：常用的方法是撤銷一些進程，回收它們的資源，將這些資源分配給被阻塞的進程，使其能夠繼續運作。

**挑戰**：由於並發進程推進順序的多樣性，系統很難有效地解除死鎖。

> 上述的四種方法，從 1）到 4）對死鎖的防範程度逐漸減弱，但對應的是資源利用率的提高，以及進程因資源因素而阻塞的頻度下降（即並發程度提高）。

## 處理死鎖的基本方法比較

![處理死鎖的基本方法比較](../../photos/jbff.png)