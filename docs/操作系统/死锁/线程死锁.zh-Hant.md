在支援多執行緒的作業系統中，執行緒死鎖是指多個執行緒因相互等待資源而導致的死鎖狀態。執行緒死鎖可以分為兩種類型：

1. **同一行程的執行緒死鎖**
 - 在同一個行程中，不同執行緒可能會因為共享相同行程的資源（如變數、記憶體等）而發生死鎖。為了同步存取這些資源，執行緒通常使用**互斥鎖（mutex）**來進行互斥操作。
 - **死鎖發生場景**：
 - 設有兩個互斥鎖：`L1` 和 `L2`。
 - 線程 `T1` 獲得了 `L1`，並請求 `L2`；
 - 線程 `T2` 獲得了 `L2`，並請求 `L1`。
 - 由於兩個執行緒互相等待對方釋放鎖，造成死鎖，兩個執行緒無法繼續執行。

 - **死鎖原因**：執行緒在持有一個鎖的同時請求另一個鎖，而該鎖被另一個執行緒持有。這種循環等待的情況導致死鎖。

2. **不同行程的執行緒死鎖**
 - 不同行程的執行緒死鎖是指兩個或更多行程中的執行緒發生相互等待，無法繼續執行。假設有兩個行程 `P1` 和 `P2`，每個行程內有多個執行緒：
 - 進程 `P1` 中的執行緒 `P11`、`P12`、...，進程 `P2` 中的執行緒 `P21`、`P22`、...；
 - 行程 `P1` 的執行緒 `P11` 獲得了資源 `R1`，行程 `P2` 的執行緒 `P21` 獲得了資源 `R2`；
 - 如果 `P11` 請求 `R2` 但無法取得，進入阻塞狀態，等待 `P21` 釋放 `R2`；
 - 同時，`P21` 請求 `R1` 但無法取得，進入阻塞狀態，等待 `P11` 釋放 `R1`；
 - 這時，`P11` 和 `P21` 互相等待對方釋放資源，導致死鎖。

 - **死鎖原因**：進程間的執行緒互相持有對方所需的資源，並且在等待中形成循環等待。

## 解決方案
執行緒死鎖的解決方法基本上與進程死鎖的解決方法類似，可以透過以下方式處理：

1. **死鎖預防**：透過限制資源的申請順序或設計資源分配規則，防止死鎖的發生。
 - 如：使用**資源排序**策略，要求執行緒以固定順序申請資源，避免形成循環等待。

2. **死鎖避免**：透過動態檢查執行緒的資源請求，確保在資源分配後系統處於**安全狀態**，從而避免死鎖。例如使用**銀行家演算法**來避免死鎖。

3. **死鎖偵測與解除**：允許系統發生死鎖，但定期執行死鎖偵測程序，識別死鎖並採取措施解決。例如：
 - **終止進程**：結束某個死鎖進程，釋放資源。
 - **回滾進程**：回退某個行程到之前的安全狀態，釋放資源。

## 總結
- **同一行程的執行緒死鎖**：執行緒因互斥鎖的申請順序錯誤或競爭導致死鎖。
- **不同行程的執行緒死鎖**：不同行程中的執行緒因相互等待資源而發生死鎖。