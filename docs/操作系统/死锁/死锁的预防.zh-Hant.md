預防死鎖的常見方法是破壞死鎖產生的四個必要條件中的一個或多個。死鎖產生的四個條件是：互斥條件、請求與保持條件、不可剝奪條件、循環等待條件。由於互斥條件是不可避免的（因為至少有一個資源是獨佔的），因此通常不考慮去破壞它。針對其他三個條件，可以採用不同的策略來避免死鎖：

## 破壞「請求與保留」條件

- **方法**：透過預先分配資源來避免進程在運行期間繼續請求資源。所有資源在進程啟動時一次分配完，進程在執行期間無法再請求新的資源。
- **優點**：
 - 簡單易實現。
 - 系統設計上較為直覺。
- **缺點**：
 - **資源利用率低**：由於預先分配可能導致某些資源處於空閒狀態，無法被其他程序利用。
 - **飢餓現象**：如果某個進程沒有及時取得到所有資源，它可能會長時間等待，導致飢餓。

這種方法適用於對資源需求預測較為準確的系統，但在多任務、大規模的複雜系統中並不總是有效。

## 破壞「不可剝奪」條件

- **方法**：採用可剝奪的資源分配方式，即允許程序在資源不足時釋放已持有的資源。進程如果無法取得所需資源，就會釋放已經佔用的資源，並在以後重新申請。
- **優點**：
 - 可以防止死鎖的發生，因為進程可以透過釋放已佔用資源來重新調整系統狀態。
- **缺點**：
 - **實作複雜**：需要在作業系統中實現資源的搶佔、保存和復原狀態的機制。
 - **代價高**：在某些資源（如記憶體、檔案）中，保存和復原狀態可能涉及較大的開銷。
- **適用範圍**：
 - 對於那些能夠方便保存和恢復狀態的資源（如 CPU 暫存器、記憶體）比較適用。

這種方法適合對資源狀態能夠進行高效保存和復原的環境，但在某些硬體或軟體環境下實現起來可能非常複雜。

## 破壞「循環等待」條件

- **方法**：透過對系統中的所有資源進行線性排序，確保資源的請求遵循一定的順序，從而避免循環等待。可以透過兩種方式實現：
 - **依序分配**：要求所有程序以資源的編號順序申請資源。
 - **先棄大，再取小**：進程在申請資源時，如果已有資源的編號大於申請資源的編號，就必須釋放已佔用的資源。
- **優點**：
 - 透過合理的資源排序，減少了死鎖的風險，系統吞吐量和資源利用率有所提高。
- **缺點**：
 - **編號順序難以滿足所有需求**：對於一些複雜的資源依賴，可能很難找到一個所有行程都滿意的資源編號順序。
 - **資源浪費**：即使某些資源可能在某時段未被使用，仍會受到排序的限制。
 - **使用者編程限制**：要求進程必須嚴格按照指定順序申請資源，這可能會限制使用者程式的靈活性。

此方法適用於資源請求較可預測且固定的場景，但在動態變更的系統中，可能會導致不必要的資源浪費和使用不便。