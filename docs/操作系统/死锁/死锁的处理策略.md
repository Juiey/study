## 1. 预防死锁

**目标**：在系统运行之前采取措施，确保不会发生死锁。

**方法**：破坏死锁产生的四个必要条件中的一个或多个，例如：

- **破坏互斥条件**：使资源可以共享，避免资源独占。
- **破坏请求和保持条件**：要求进程在持有资源时不能请求新的资源。
- **破坏不剥夺条件**：允许系统强制剥夺资源。
- **破坏循环等待条件**：确保资源请求按某一顺序进行，避免形成循环等待。

## 2. 避免死锁

**目标**：通过动态分配资源，防止系统进入不安全状态，从而避免死锁。

**方法**：例如银行家算法，在资源分配时，模拟资源分配后的状态，只有当资源分配不会导致死锁时，才实际分配资源。

**缺点**：

- 资源申请分析和计算复杂，系统开销大。
- 很难在进程执行前精确掌握每个进程所需的最大资源数。

## 3. 检测死锁

**目标**：允许系统在运行过程中发生死锁，但通过检测机制及时检测出死锁。

**方法**：使用资源分配图或其他算法定期检查系统的状态，检测是否存在死锁。
**缺点**：需要通过剥夺资源解除死锁，可能对系统或用户造成损失。

## 4. 解除死锁

**目标**：在检测到死锁后，采取措施将进程从死锁状态中解脱出来。

**方法**：常用的方法是撤销一些进程，回收它们的资源，将这些资源分配给被阻塞的进程，使其能够继续运行。

**挑战**：由于并发进程推进顺序的多样性，系统很难有效地解除死锁。

> 上述的四种方法，从 1）到 4）对死锁的防范程度逐渐减弱，但对应的是资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）。

## 处理死锁的基本方法比较

![处理死锁的基本方法比较](../../photos/jbff.png)